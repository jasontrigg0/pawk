pawk is a python-based replacement for awk.

Basic examples:

#output only columns a,c,b in that order
pawk.py -f input.txt -c a,c,b

#output only column 1 (zero-indexed)
pawk.py -f input.txt -c1

#add one to column b
pawk.py -f input.txt -p 'r["b"] = float(r["b"]) + 1'

#create new column max which is the maximum of columns 0 and 1
pawk.py -f input.txt -a max -p 'r["max"] = max(float(r[0]),float(r[1]))'

#create new column concat
pawk.py -f input.txt -a concat -p 'r["concat"] = r["a"] + r["b"]'

#choose only rows where column 2 is greater than 10
pawk.py -f input.txt -g 'float(r[2]) > 10'

#choose rows where some column has "day" in it
pawk.py -f input.txt -g '/day/'

#output only rows after the first 10 (i = 0 is the header, which is automatically outputed)
pawk.py -f input.txt -g 'i>10'






Writing multi-line python in pawk:
Heavily inspired by a source I can't find right now, pawk uses the python_indent function to process strings representing multi-line python. 

examples:
#(semi-colon) or (colon+whitespace) causes a line break
'import random; print random.random()'
-->
import random;
print random.random()


#after lines with (colon+whitespace) successive lines are automatically indented:
'if i>3: print "hello world!"; a += 1; b = 0'
-->
if i>3:
   print "hello world!";
   a += 1;
   b == 0


#use the 'end;' keyword to force indent level to decrease (compare this example with the above)
'if i>3: print "hello world!"; end; a += 1; b = 0'
-->
if i>3:
   print "hello world!";
a += 1;
b = 0


#"elif:", "else:" and "except:" automatically cause indenting to decrease
'if i>3: print "a"; elif i>1: print "b"; else: print "c"'
-->
if i>3:
   print "a";
elif i>1:
   print "b";
else:
   print "c"


#you can define functions!
'def test123(): print "hello world!" end; test123(); test123(); test123();'
->
def test123():
    print "hello world!"
test123();
test123();
test123();